{"componentChunkName":"component---src-templates-blog-post-js","path":"/lean-type-safety/","result":{"data":{"site":{"siteMetadata":{"title":"Aditya Srinivasan"}},"mdx":{"id":"5cdcd612-2817-56e0-895c-090c87cfa8ea","excerpt":"For my final project in  CS242 , I used\nthe  Lean  theorem prover to prove type safety\nfor a small, toy language. In order to prove type safety, I proved threeâ€¦","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Proving Type Safety in Lean\",\n  \"published_on\": \"2021-12-03\",\n  \"type\": \"project\",\n  \"draft\": false,\n  \"tags\": [\"pl\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"For my final project in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://web.stanford.edu/class/cs242/\"\n  }, \"CS242\"), \", I used\\nthe \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://leanprover.github.io/\"\n  }, \"Lean\"), \" theorem prover to prove type safety\\nfor a small, toy language.\"), mdx(\"p\", null, \"In order to prove type safety, I proved three distinct properties:\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Theorem\"), \" (Progress): For any expression \", mdx(IM, {\n    mdxType: \"IM\"\n  }, \"e\"), \", either \", mdx(IM, {\n    mdxType: \"IM\"\n  }, \"e\"), \" is a value, or there exists \", mdx(IM, {\n    mdxType: \"IM\"\n  }, \"e'\"), \" such that \", mdx(IM, {\n    mdxType: \"IM\"\n  }, \"e\"), \" evaluates to \", mdx(IM, {\n    mdxType: \"IM\"\n  }, \"e'\"), \" in one step. Formally, \", mdx(IM, {\n    mdxType: \"IM\"\n  }, \"\\\\forall e \\\\in \\\\mathcal{E}. e \\\\textbf{ val} \\\\vee (\\\\exists e' \\\\in \\\\mathcal{E}. e \\\\mapsto e')\"), \".\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Theorem\"), \" (Totality): For any expression \", mdx(IM, {\n    mdxType: \"IM\"\n  }, \"e\"), \", there exists \", mdx(IM, {\n    mdxType: \"IM\"\n  }, \"e'\"), \" such that \", mdx(IM, {\n    mdxType: \"IM\"\n  }, \"e'\"), \" is a value and \", mdx(IM, {\n    mdxType: \"IM\"\n  }, \"e\"), \" evaluates to \", mdx(IM, {\n    mdxType: \"IM\"\n  }, \"e'\"), \" in zero or more steps. Formally, \", mdx(IM, {\n    mdxType: \"IM\"\n  }, \"\\\\forall e \\\\in \\\\mathcal{E}. \\\\exists e' \\\\in \\\\mathcal{E}. e' \\\\textbf{ val} \\\\wedge e \\\\mapsto^* e'\"), \".\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Theorem\"), \" (Preservation): If \", mdx(IM, {\n    mdxType: \"IM\"\n  }, \"e\"), \" is a natural number in the initial type environment, and \", mdx(IM, {\n    mdxType: \"IM\"\n  }, \"e\"), \" evaluates to \", mdx(IM, {\n    mdxType: \"IM\"\n  }, \"e'\"), \" in one step, then \", mdx(IM, {\n    mdxType: \"IM\"\n  }, \"e'\"), \" is a natural number in the initial type environment. Formally, \", mdx(IM, {\n    mdxType: \"IM\"\n  }, \"\\\\forall e, e' \\\\in \\\\mathcal{E}. 0 \\\\vdash e : \\\\textbf{ nat} \\\\wedge e \\\\mapsto e' \\\\rightarrow 0 \\\\vdash e' : \\\\textbf{ nat}\"), \".\"), mdx(\"p\", null, \"Lean's type system is more advanced than that of any other language I have used.\\nIt is based on a version of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Dependent_type\"\n  }, \"dependent type\\ntheory\"), \" known as the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Calculus_of_constructions\"\n  }, \"calculus of\\nconstructions\"), mdx(\"sup\", {\n    parentName: \"p\",\n    \"id\": \"fnref-1\"\n  }, mdx(\"a\", {\n    parentName: \"sup\",\n    \"href\": \"#fn-1\",\n    \"className\": \"footnote-ref\"\n  }, \"1\")), \",\\nwith a countable hierarchy\", mdx(\"sup\", {\n    parentName: \"p\",\n    \"id\": \"fnref-2\"\n  }, mdx(\"a\", {\n    parentName: \"sup\",\n    \"href\": \"#fn-2\",\n    \"className\": \"footnote-ref\"\n  }, \"2\")), \" of non-cumulative universes and inductive types.\\nThis powerful type system provides the necessary power and expressivity to\\nformalize proofs about complex systems within the language.\"), mdx(\"p\", null, \"Although there are many ways to write proofs in Lean, I mostly used\\n\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://leanprover.github.io/theorem_proving_in_lean/tactics.html\"\n  }, \"tactics\"), \". As\\ndescribed in the documentation, tactics \\\"support an incremental style of writing\\nproofs, in which users decompose a proof and work on goals one step at a time\\\".\"), mdx(\"p\", null, \"There's a special tactic called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sorry\"), \", which automatically satisfies the\\nrelevant goal in scope, though it also displays a warning at the enclosing\\ntheorem or lemma, since the proof is technically incomplete. This led to a very\\npleasant programming experience, since I was able to stub out the complicated\\nparts of the proof with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"sorry\"), \", work on the easier bits, and then revisit the\\nharder ones once I was confident that the proof structure was sound. In fact, we\\noften do this in programming. In OCaml, for example, you can stub out a function\\nas follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ocaml\"\n  }, \"let fib (x : int) : int = raise_s [%message \\\"Not implemented!\\\"]\\n\")), mdx(\"p\", null, \"This will type-check\", mdx(\"sup\", {\n    parentName: \"p\",\n    \"id\": \"fnref-3\"\n  }, mdx(\"a\", {\n    parentName: \"sup\",\n    \"href\": \"#fn-3\",\n    \"className\": \"footnote-ref\"\n  }, \"3\")), \", letting you use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"fib\"), \" in the rest of your program as\\nif it were implemented correctly.\"), mdx(\"h2\", null, \"Footnotes\"), mdx(\"div\", {\n    \"className\": \"footnotes\"\n  }, mdx(\"hr\", {\n    parentName: \"div\"\n  }), mdx(\"ol\", {\n    parentName: \"div\"\n  }, mdx(\"li\", {\n    parentName: \"ol\",\n    \"id\": \"fn-1\"\n  }, \"This type theory is also the basis of other proof assistants, such as\\n\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://en.wikipedia.org/wiki/Coq\"\n  }, \"Coq\"), \". \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#fnref-1\",\n    \"className\": \"footnote-backref\"\n  }, \"\\u21A9\")), mdx(\"li\", {\n    parentName: \"ol\",\n    \"id\": \"fn-2\"\n  }, \"The type theory utilizes a hierarchy of such universes in order to avoid\\n\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://en.wikipedia.org/wiki/System_U#Girard's_paradox\"\n  }, \"Girard's paradox\"), \", the\\ntype-theoretical equivalent of \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://en.wikipedia.org/wiki/Russell%27s_paradox\"\n  }, \"Russell's\\nparadox\"), \". \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#fnref-2\",\n    \"className\": \"footnote-backref\"\n  }, \"\\u21A9\")), mdx(\"li\", {\n    parentName: \"ol\",\n    \"id\": \"fn-3\"\n  }, \"Interestingly, this exposes a deficiency of OCaml as it exists today, which\\nis that it doesn't support algebraic effects. If it did, the function signature\\nmay encode the fact that it throws an exception (e.g. using some imaginary\\nsyntax, \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"int -> int exn\"), \"), which is different from the desired signature. \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#fnref-3\",\n    \"className\": \"footnote-backref\"\n  }, \"\\u21A9\")))));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Proving Type Safety in Lean","published_on":"December 03, 2021","updated_on":null,"description":null,"tags":["pl"],"draft":false,"bookish":null},"fields":{"readingTime":{"text":"3 min read"}}},"previous":{"fields":{"slug":"/the-dark-forest/"},"frontmatter":{"title":"Bookish #1: The Dark Forest"}},"next":{"fields":{"slug":"/project-hail-mary/"},"frontmatter":{"title":"Bookish #2: Project Hail Mary"}}},"pageContext":{"id":"5cdcd612-2817-56e0-895c-090c87cfa8ea","previousPostId":"235651bc-c24e-58d1-913f-1bc91cd254ff","nextPostId":"1baef677-1637-55c1-8415-8134a0a35fef"}},"staticQueryHashes":["234287855","2433109408","4239340312"]}