{"componentChunkName":"component---src-templates-blog-post-js","path":"/lightweight-dependent-in-ocaml/","result":{"data":{"site":{"siteMetadata":{"title":"Aditya Srinivasan"}},"mdx":{"id":"174d42fd-1fdd-525c-9726-d28ea2fe6de5","excerpt":"Introduction Dependent typing  is a powerful\nfeature of systems, though it is endowed to few mainstream programming\nlanguages . This isn't all that surprisingâ€¦","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Lightweight Dependent Types in OCaml\",\n  \"published_on\": \"2022-01-23\",\n  \"type\": \"blog-post\",\n  \"tags\": [\"pl\"],\n  \"draft\": true\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h3\", null, \"Introduction\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Dependent_type\"\n  }, \"Dependent typing\"), \" is a powerful\\nfeature of systems, though it is endowed to few mainstream programming\\nlanguages\", mdx(\"sup\", {\n    parentName: \"p\",\n    \"id\": \"fnref-1\"\n  }, mdx(\"a\", {\n    parentName: \"sup\",\n    \"href\": \"#fn-1\",\n    \"className\": \"footnote-ref\"\n  }, \"1\")), \". This isn't all that surprising for at least two reasons For one,\\nthere are many features of programming languages for which the journey from\\nbeing theorized to being implemented and widely available in common programming\\nlanguages is long and slow\", mdx(\"sup\", {\n    parentName: \"p\",\n    \"id\": \"fnref-2\"\n  }, mdx(\"a\", {\n    parentName: \"sup\",\n    \"href\": \"#fn-2\",\n    \"className\": \"footnote-ref\"\n  }, \"2\")), \". Second, dependent types add complexity to the\\ntype system, both to the programmer who needs to learn what they are, as well as\\nto the compiler which may need to evaluate costly expressions in order to\\ndetermine type-equality during type-checking.\"), mdx(\"p\", null, \"However, all is not lost! Even languages without first-class support for\\ndependent types can be coerced into providing something resembling (admittedly,\\na much weaker version of) it. I decided to try this out with OCaml, which does\\nnot support dependent types in a first-class way, but does have a sophisticated\\ntype system. (It's worth saying that I set out to do this purely for fun; this\\nis almost certainly not something I'd want to find in an actual production\\ncodebase.)\"), mdx(\"p\", null, \"Throughout the course of this post, we'll build up a representation of a list\\nthat encodes its length in its type, as well as a function that lets one index\\ninto the list \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"safely\"), \". That is, at compile-time one can be guaranteed to\\navoid indexing out-of-bounds. To reiterate, this is far from fully-fledged\\ndependent typing, but it gives us a taste.\"), mdx(\"p\", null, \"Finally, I won't assume the reader has a deep familiarity with OCaml or other\\nlanguages in the ML family, and will attempt to explain things as I go.\"), mdx(\"h3\", null, \"Plain Ol' Non-Dependent Types\"), mdx(\"p\", null, \"First, what do lists and indexing look like with the native types provided by\\nthe OCaml standard library?\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ocaml\"\n  }, \"type 'a list =\\n    | []\\n    | ( :: ) of 'a * 'a list\\n\")), mdx(\"p\", null, \"We'll make two observations about this type definition. First, this type is\\npolymorphic. This means that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"list\"), \" is a \\\"type constructor\\\", as opposed to a\\nconcrete type itself. It can be thought of as a \\\"function\\\" operating on types.\\nSo, if we apply the type constructor \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"list\"), \" to a concrete type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"int\"), \", we get a\\nconcrete type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"int list\"), \". We can apply this to arbitrary depth; applying the\\ntype constructor \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"list\"), \" to concrete type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"int list\"), \" yields the concrete type\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"int list list\"), \".\"), mdx(\"p\", null, \"Second, this type is defined inductively. There are many names for types like\\nthis, including sum types and union types, but the inductive definition seems\\nnatural to me. The \\\"base case\\\" for constructing a list is the empty list: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[]\"), \".\\nThe \\\"inductive case\\\" for constructing a list says: \\\"if you have an element\\n(\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'a\"), \") and a list of those elements (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'a list\"), \"), you can construct another list\\n(\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'a list\"), \") that is semantically the concatenation of the two\\\".\"), mdx(\"p\", null, \"It's worth noting that in OCaml, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[ x; y ]\"), \" is syntactic sugar for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"x :: y :: []\"), \" which is further syntactic sugar for \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"( :: ) (x, ( :: ) (y, []))\"), \". This\\ngives us a much more natural way to specify list literals:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ocaml\"\n  }, \"[ 1; 2 ];;\\n- : int list = (::) (1, (::) (2, []))\\n\")), mdx(\"p\", null, \"How can we index into a list? The standard library gives us a function, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"List.nth\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ocaml\"\n  }, \"List.nth;;\\n- : 'a list -> int -> 'a = <fun>\\n\")), mdx(\"p\", null, \"This type signature should make sense. Given a list of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'a\"), \"s and an integer\\nindex, retrieve the element at that index which is of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'a\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ocaml\"\n  }, \"List.nth [ 1 ] 0;;\\n- : int = 1\\n\")), mdx(\"p\", null, \"However, what this type signature does not capture is that this function can\\nraise an exception if the index is out of bounds\", mdx(\"sup\", {\n    parentName: \"p\",\n    \"id\": \"fnref-3\"\n  }, mdx(\"a\", {\n    parentName: \"sup\",\n    \"href\": \"#fn-3\",\n    \"className\": \"footnote-ref\"\n  }, \"3\")), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ocaml\"\n  }, \"List.nth [ 1 ] 1;;\\nException: (Failure nth)\\nRaised at Stdlib.failwith in file \\\"stdlib.ml\\\", line 29, characters 17-33\\n\")), mdx(\"h3\", null, mdx(IM, {\n    mdxType: \"IM\"\n  }, \"\\\\mathbb{N}\"), \" as Types\"), mdx(\"p\", null, \"Our first observation is that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"list\"), \" type encodes information about the type\\nof its elements, but not about its length. If we want the type system to make it\\nimpossible to express indexing operations that violate our bounds, then we need\\nsome way to encode numbers as types. Therefore, we first turn our attention to\\nencoding each natural number in \", mdx(IM, {\n    mdxType: \"IM\"\n  }, \"\\\\mathbb{N}\"), \" as a distinct type.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ocaml\"\n  }, \"module Number = struct\\n  type zero = [ `zero ]\\n\\n  type 'n succ = [ `succ of 'n ]\\n\\n  type 'n t =\\n    | Zero : zero t\\n    | Succ : 'n t -> 'n succ t\\nend\\n\")), mdx(\"p\", null, \"Let's break this down. We first declare two types as singleton polymorphic\\nvariables: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"zero\"), \" whose only constructor is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"`zero\"), \", and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'n succ\"), \" whose\\nonly constructor is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"`succ of 'n\"), \". These give us names for the type\\nparameters we'll use next. Finally, we declare the type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'n t\"), \"as a generalized\\nalgebraic data type (GADT) with two constructors. The first constructor,\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Zero\"), \",\\ngives us a value of type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"zero t\"), \". The second constructor, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Succ\"), \", takes some\\n\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'n t\"), \"and gives us a value of type\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'n succ t\"), \".\"), mdx(\"p\", null, \"This should indeed sound familiar; this is an inductive definition of the\\nnatural numbers. That is, you can specify the number zero using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Zero\"), \". If you\\nhave a number \", mdx(IM, {\n    mdxType: \"IM\"\n  }, \"n\"), \", you can specify \", mdx(IM, {\n    mdxType: \"IM\"\n  }, \"\\\\mathsf{succ}(n)\"), \" using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Succ\"), \".\\nMoreover, the value's type fully encodes the semantic number it is associated\\nwith.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ocaml\"\n  }, \"open Number\\n\\nlet zero : zero t           = Zero\\nlet one  : zero succ t      = Succ Zero\\nlet two  : zero succ succ t = Succ (Succ Zero)\\n\")), mdx(\"h3\", null, \"Typed Lengths\"), mdx(\"p\", null, \"Now that we have a type for natural numbers, we can move on to defining our list\\ntype that encodes its length.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ocaml\"\n  }, \"module List = struct\\n  type ('a, 'len) t =\\n    | [] : ('a, Number.zero Number.t) t\\n    | ( :: ) : 'a * ('a, 'len Number.t) t -> ('a, 'len Number.succ Number.t) t\\nend\\n\")), mdx(\"p\", null, \"This should look very similar to the original definition of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'a list\"), \", except\\nwe've introduced an additional parameter for the length: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'len\"), \". Additionally,\\nwe're using GADTs to \\\"refine\\\" the type of the value you get when using either of\\nthe two constructors. In particular, the empty list \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[]\"), \" is polymorphic in the\\nelement, but its length is fixed as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Number.zero Number.t\"), \". Similarly, given an\\nelement and a list of length \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'len Number.t\"), \", the constructor \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"( :: )\"), \" produces\\na list of elements of length \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'len Number.succ Number.t\"), \". Let's see this in\\naction.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ocaml\"\n  }, \"let nil       : (Number.zero Number.t, 'a) List.t                             = List.[]\\nlet singleton : (Number.zero Number.succ Number.t, int) List.t                = List.[ 1 ]\\nlet pair      : (Number.zero Number.succ Number.succ Number.t, string) List.t = List.[ \\\"a\\\"; \\\"b\\\" ]\\n\")), mdx(\"p\", null, \"Recall that the original \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"List.nth\"), \" function could raise an exception if the\\nprovided index was out of bounds. Now that we have lists that typefully encode\\ntheir length, let's create a type-safe version of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"List.nth\"), \".\"), mdx(\"p\", null, \"The first thing you may realize is that the type signature \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"val nth : ('a, 'len) List.t -> n:'n Number.t -> 'a\"), \" is actually insufficient. Nothing reflects that\\nthe number \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'n\"), \" is less than the number \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'len\"), \"', so we have no guarantees that\\nthe argument \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"n\"), \" will be within bounds. We can address this by introducing a\\ntype to \\\"prove\\\" that a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'x\"), \" is less than a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'y\"), \".\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ocaml\"\n  }, \"module LT = struct\\n  type ('x, 'y) t =\\n    (* For any x, 0 is less than succ(x) *)\\n    | Zero : 'x Number.t -> (Number.zero Number.t, 'x Number.succ Number.t) t\\n    (* For any x, x is less than succ(x) *)\\n    | Succ : 'x Number.t -> ('x Number.t, 'x Number.succ Number.t) t\\n    (* For any x and y, if x < y and y < z, then x < z *)\\n    | Trans :\\n        ('x Number.t, 'y Number.t) t * ('y Number.t, 'z Number.t) t\\n        -> ('x Number.t, 'z Number.t) t\\nend\\n\")), mdx(\"p\", null, \"By carefully encoding some basic axioms and rules via our constructors, we've\\ndefined a type whose values serve as proofs that some number \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'x\"), \" is less than\\nanother number \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"'y\"), \".\"), mdx(\"h3\", null, \"Footnotes\"), mdx(\"div\", {\n    \"className\": \"footnotes\"\n  }, mdx(\"hr\", {\n    parentName: \"div\"\n  }), mdx(\"ol\", {\n    parentName: \"div\"\n  }, mdx(\"li\", {\n    parentName: \"ol\",\n    \"id\": \"fn-1\"\n  }, \"I wrote about a programming language with a sophisticated dependent typing\\nimplementation in \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"/lean-type-safety\"\n  }, \"another post\"), \".\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#fnref-1\",\n    \"className\": \"footnote-backref\"\n  }, \"\\u21A9\")), mdx(\"li\", {\n    parentName: \"ol\",\n    \"id\": \"fn-2\"\n  }, \"A striking example is that of \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://en.wikipedia.org/wiki/Tagged_union\"\n  }, \"sum\\ntypes\"), \", which many popular\\nprogramming languages do not support as a first-class primitive.\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#fnref-2\",\n    \"className\": \"footnote-backref\"\n  }, \"\\u21A9\")), mdx(\"li\", {\n    parentName: \"ol\",\n    \"id\": \"fn-3\"\n  }, \"For OCaml to express this in the type system would require a feature called\\n\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://en.wikipedia.org/wiki/Effect_system\"\n  }, \"algebraic effects\"), \".\", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"#fnref-3\",\n    \"className\": \"footnote-backref\"\n  }, \"\\u21A9\")))));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Lightweight Dependent Types in OCaml","published_on":"January 23, 2022","updated_on":null,"description":null,"tags":["pl"],"draft":true,"bookish":null},"fields":{"readingTime":{"text":"8 min read"}}},"previous":{"fields":{"slug":"/youtube-channels/"},"frontmatter":{"title":"My Favorite YouTube Channels"}},"next":{"fields":{"slug":"/one-million-meters/"},"frontmatter":{"title":"One Million Meters"}}},"pageContext":{"id":"174d42fd-1fdd-525c-9726-d28ea2fe6de5","previousPostId":"79ffa651-cc6c-5e50-816d-818b2b2606f3","nextPostId":"632987db-f094-57b5-b4db-f2710b17cc1e"}},"staticQueryHashes":["234287855","2433109408","4239340312"]}